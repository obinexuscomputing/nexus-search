{"version":3,"file":"nexus-search.umd.js","sources":["../src/storage/CacheManager.ts","../src/storage/SearchStorage.ts","../src/utils/SearchUtils.ts","../src/utils/ValidationUtils.ts","../src/mappers/DataMapper.ts","../src/algorithms/trie/TrieNode.ts","../src/algorithms/trie/TrieSearch.ts","../src/mappers/IndexMapper.ts","../src/storage/IndexManager.ts","../src/core/QueryProcessor.ts","../src/core/SearchEngine.ts","../src/types/errors.ts","../src/types/cache.ts","../src/index.ts","../src/storage/IndexedDBService.ts","../src/utils/PerformanceUtils.ts"],"sourcesContent":["import { CacheEntry, CacheStrategy, SearchResult } from \"@/types\";\r\n\r\n\r\n\r\nexport class CacheManager {\r\n    private cache: Map<string, CacheEntry>;\r\n    private readonly maxSize: number;\r\n    private readonly ttl: number;\r\n    private strategy: CacheStrategy; // Changed from readonly to private\r\n    private accessOrder: string[];\r\n    private stats: {\r\n        hits: number;\r\n        misses: number;\r\n        evictions: number;\r\n    };\r\n\r\n    constructor(\r\n        maxSize: number = 1000, \r\n        ttlMinutes: number = 5, \r\n        initialStrategy: CacheStrategy = 'LRU'\r\n    ) {\r\n        this.cache = new Map();\r\n        this.maxSize = maxSize;\r\n        this.ttl = ttlMinutes * 60 * 1000;\r\n        this.strategy = initialStrategy;\r\n        this.accessOrder = [];\r\n        this.stats = {\r\n            hits: 0,\r\n            misses: 0,\r\n            evictions: 0\r\n        };\r\n    }\r\n\r\n    set(key: string, data: SearchResult<unknown>[]): void {\r\n        if (this.cache.size >= this.maxSize) {\r\n            this.evict();\r\n        }\r\n\r\n        const entry: CacheEntry = {\r\n            data,\r\n            timestamp: Date.now(),\r\n            lastAccessed: Date.now(),\r\n            accessCount: 1\r\n        };\r\n\r\n        this.cache.set(key, entry);\r\n        this.updateAccessOrder(key);\r\n    }\r\n\r\n    get(key: string): SearchResult<unknown>[] | null {\r\n        const entry = this.cache.get(key);\r\n\r\n        if (!entry) {\r\n            this.stats.misses++;\r\n            return null;\r\n        }\r\n\r\n        if (this.isExpired(entry.timestamp)) {\r\n            this.cache.delete(key);\r\n            this.removeFromAccessOrder(key);\r\n            this.stats.misses++;\r\n            return null;\r\n        }\r\n\r\n        entry.lastAccessed = Date.now();\r\n        entry.accessCount++;\r\n        this.updateAccessOrder(key);\r\n        this.stats.hits++;\r\n\r\n        return entry.data;\r\n    }\r\n\r\n    clear(): void {\r\n        this.cache.clear();\r\n        this.accessOrder = [];\r\n        this.stats = {\r\n            hits: 0,\r\n            misses: 0,\r\n            evictions: 0\r\n        };\r\n    }\r\n\r\n    getStats() {\r\n        return {\r\n            ...this.stats,\r\n            size: this.cache.size,\r\n            maxSize: this.maxSize,\r\n            hitRate: this.stats.hits / (this.stats.hits + this.stats.misses),\r\n            strategy: this.strategy\r\n        };\r\n    }\r\n\r\n    private isExpired(timestamp: number): boolean {\r\n        return Date.now() - timestamp > this.ttl;\r\n    }\r\n\r\n    private evict(): void {\r\n        const keyToEvict = this.strategy === 'LRU' \r\n            ? this.findLRUKey()\r\n            : this.findMRUKey();\r\n\r\n        if (keyToEvict) {\r\n            this.cache.delete(keyToEvict);\r\n            this.removeFromAccessOrder(keyToEvict);\r\n            this.stats.evictions++;\r\n        }\r\n    }\r\n\r\n    private findLRUKey(): string | null {\r\n        return this.accessOrder[0] || null;\r\n    }\r\n\r\n    private findMRUKey(): string | null {\r\n        return this.accessOrder[this.accessOrder.length - 1] || null;\r\n    }\r\n\r\n    private updateAccessOrder(key: string): void {\r\n        this.removeFromAccessOrder(key);\r\n\r\n        if (this.strategy === 'LRU') {\r\n            this.accessOrder.push(key); // Most recently used at end\r\n        } else {\r\n            this.accessOrder.unshift(key); // Most recently used at start\r\n        }\r\n    }\r\n\r\n    private removeFromAccessOrder(key: string): void {\r\n        const index = this.accessOrder.indexOf(key);\r\n        if (index !== -1) {\r\n            this.accessOrder.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    setStrategy(newStrategy: CacheStrategy): void {\r\n        if (newStrategy === this.strategy) return;\r\n        \r\n        this.strategy = newStrategy;\r\n        const entries = [...this.accessOrder];\r\n        this.accessOrder = [];\r\n        entries.forEach(key => this.updateAccessOrder(key));\r\n    }\r\n\r\n    prune(): number {\r\n        let prunedCount = 0;\r\n        for (const [key, entry] of this.cache.entries()) {\r\n            if (this.isExpired(entry.timestamp)) {\r\n                this.cache.delete(key);\r\n                this.removeFromAccessOrder(key);\r\n                prunedCount++;\r\n            }\r\n        }\r\n        return prunedCount;\r\n    }\r\n\r\n    analyze(): {\r\n        hitRate: number;\r\n        averageAccessCount: number;\r\n        mostAccessedKeys: Array<{ key: string; count: number }>;\r\n    } {\r\n        const totalAccesses = this.stats.hits + this.stats.misses;\r\n        const hitRate = totalAccesses > 0 ? this.stats.hits / totalAccesses : 0;\r\n\r\n        let totalAccessCount = 0;\r\n        const accessCounts = new Map<string, number>();\r\n\r\n        for (const [key, entry] of this.cache.entries()) {\r\n            totalAccessCount += entry.accessCount;\r\n            accessCounts.set(key, entry.accessCount);\r\n        }\r\n\r\n        const averageAccessCount = this.cache.size > 0 \r\n            ? totalAccessCount / this.cache.size \r\n            : 0;\r\n\r\n        const mostAccessedKeys = Array.from(accessCounts.entries())\r\n            .sort((a, b) => b[1] - a[1])\r\n            .slice(0, 5)\r\n            .map(([key, count]) => ({ key, count }));\r\n\r\n        return {\r\n            hitRate,\r\n            averageAccessCount,\r\n            mostAccessedKeys\r\n        };\r\n    }\r\n}","import { openDB, IDBPDatabase } from 'idb';\nimport type { SearchDBSchema, StorageOptions } from '@/types';\n\nexport class SearchStorage {\n    private db: IDBPDatabase<SearchDBSchema> | null = null;\n    private memoryStorage: Map<string, unknown> = new Map();\n    private storageType: 'indexeddb' | 'memory';\n\n    constructor(options: StorageOptions = {\n        type: 'memory'\n    }) {\n        this.storageType = this.determineStorageType(options);\n    }\n\n    private determineStorageType(options: StorageOptions): 'indexeddb' | 'memory' {\n        // Use memory storage if explicitly specified or if in Node.js environment\n        if (options.type === 'memory' || !this.isIndexedDBAvailable()) {\n            return 'memory';\n        }\n        return 'indexeddb';\n    }\n\n    private isIndexedDBAvailable(): boolean {\n        try {\n            return typeof indexedDB !== 'undefined' && indexedDB !== null;\n        } catch {\n            return false;\n        }\n    }\n\n    async initialize(): Promise<void> {\n        if (this.storageType === 'memory') {\n            // No initialization needed for memory storage\n            return;\n        }\n\n        try {\n            this.db = await openDB<SearchDBSchema>('nexus-search-db', 1, {\n                upgrade(db) {\n                    const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\n                    indexStore.createIndex('timestamp', 'timestamp');\n\n                    const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\n                    metaStore.createIndex('lastUpdated', 'lastUpdated');\n                }\n            });\n        } catch (error) {\n            // Fallback to memory storage if IndexedDB fails\n            this.storageType = 'memory';\n            console.warn('Failed to initialize IndexedDB, falling back to memory storage:', error);\n        }\n    }\n\n    async storeIndex(name: string, data: unknown): Promise<void> {\n        if (this.storageType === 'memory') {\n            this.memoryStorage.set(name, data);\n            return;\n        }\n\n        try {\n            await this.db?.put('searchIndices', {\n                id: name,\n                data,\n                timestamp: Date.now()\n            });\n        } catch (error) {\n            console.error('Storage error:', error);\n            // Fallback to memory storage\n            this.memoryStorage.set(name, data);\n        }\n    }\n\n    async getIndex(name: string): Promise<unknown> {\n        if (this.storageType === 'memory') {\n            return this.memoryStorage.get(name);\n        }\n\n        try {\n            const entry = await this.db?.get('searchIndices', name);\n            return entry?.data;\n        } catch (error) {\n            console.error('Retrieval error:', error);\n            // Fallback to memory storage\n            return this.memoryStorage.get(name);\n        }\n    }\n\n    async clearIndices(): Promise<void> {\n        if (this.storageType === 'memory') {\n            this.memoryStorage.clear();\n            return;\n        }\n\n        try {\n            await this.db?.clear('searchIndices');\n        } catch (error) {\n            console.error('Clear error:', error);\n            this.memoryStorage.clear();\n        }\n    }\n\n    async close(): Promise<void> {\n        if (this.db) {\n            this.db.close();\n            this.db = null;\n        }\n        this.memoryStorage.clear();\n    }\n}","import { DocumentValue, IndexableDocument, OptimizationResult } from \"@/types\";\r\n\r\ntype DocumentContent = {\r\n    [key: string]: DocumentValue | DocumentContent;\r\n};\r\n\r\nexport function createSearchableFields<T extends IndexableDocument>(\r\n    document: T,\r\n    fields: string[]\r\n): Record<string, string> {\r\n    const searchableFields: Record<string, string> = {};\r\n    fields.forEach(field => {\r\n        const value = getNestedValue(document.content, field);\r\n        if (value !== undefined) {\r\n            searchableFields[field] = normalizeFieldValue(value);\r\n        }\r\n    });\r\n    return searchableFields;\r\n}\r\n\r\nexport function normalizeFieldValue(value: DocumentValue): string {\r\n    if (typeof value === 'string') {\r\n        return value.toLowerCase().trim();\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return value.map(v => normalizeFieldValue(v)).join(' ');\r\n    }\r\n    if (typeof value === 'object' && value !== null) {\r\n        return Object.values(value).map(v => normalizeFieldValue(v)).join(' ');\r\n    }\r\n    return String(value);\r\n}\r\n\r\nexport function getNestedValue(obj: DocumentContent, path: string): DocumentValue | undefined {\r\n    const keys = path.split('.');\r\n    let current: DocumentValue | DocumentContent = obj;\r\n\r\n    for (const key of keys) {\r\n        if (current && typeof current === 'object' && !Array.isArray(current) && key in current) {\r\n            current = current[key];\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    return current as DocumentValue;\r\n}\r\n\r\nexport function optimizeIndex<T extends IndexableDocument>(data: T[]): OptimizationResult<T> {\r\n    const uniqueData = Array.from(new Set(data.map(item =>\r\n        JSON.stringify(item)\r\n    ))).map(item => JSON.parse(item)) as T[];\r\n\r\n    const sorted = uniqueData.sort((a, b) =>\r\n        JSON.stringify(a).localeCompare(JSON.stringify(b))\r\n    );\r\n\r\n    return {\r\n        data: sorted,\r\n        stats: {\r\n            originalSize: data.length,\r\n            optimizedSize: sorted.length,\r\n            compressionRatio: sorted.length / data.length\r\n        }\r\n    };\r\n}","import { SearchOptions, IndexConfig, SearchableDocument } from \"@/types\";\r\nimport { getNestedValue } from \"./SearchUtils\";\r\n\r\nexport function validateSearchOptions(options: SearchOptions): void {\r\n    if (options.maxResults && options.maxResults < 1) {\r\n        throw new Error('maxResults must be greater than 0');\r\n    }\r\n    if (options.threshold && (options.threshold < 0 || options.threshold > 1)) {\r\n        throw new Error('threshold must be between 0 and 1');\r\n    }\r\n    if (options.fields && !Array.isArray(options.fields)) {\r\n        throw new Error('fields must be an array');\r\n    }\r\n}\r\n\r\nexport function validateIndexConfig(config: IndexConfig): void {\r\n    if (!config.name) {\r\n        throw new Error('Index name is required');\r\n    }\r\n    if (!config.version || typeof config.version !== 'number') {\r\n        throw new Error('Valid version number is required');\r\n    }\r\n    if (!Array.isArray(config.fields) || config.fields.length === 0) {\r\n        throw new Error('At least one field must be specified for indexing');\r\n    }\r\n}\r\n\r\nexport function validateDocument(document: SearchableDocument, fields: string[]): boolean {\r\n    return fields.every(field => {\r\n        const value = getNestedValue(document.content, field);\r\n        return value !== undefined;\r\n    });\r\n}","export class DataMapper {\r\n  private dataMap: Map<string, Set<string>>;\r\n\r\n  constructor() {\r\n    this.dataMap = new Map();\r\n  }\r\n\r\n  mapData(key: string, documentId: string): void {\r\n    if (!this.dataMap.has(key)) {\r\n      this.dataMap.set(key, new Set());\r\n    }\r\n    this.dataMap.get(key)!.add(documentId);\r\n  }\r\n\r\n  getDocuments(key: string): Set<string> {\r\n    return this.dataMap.get(key) || new Set();\r\n  }\r\n\r\n  getAllKeys(): string[] {\r\n    return Array.from(this.dataMap.keys());\r\n  }\r\n\r\n  exportState(): Record<string, string[]> {\r\n    const serializedMap: Record<string, string[]> = {};\r\n    \r\n    this.dataMap.forEach((value, key) => {\r\n      serializedMap[key] = Array.from(value);\r\n    });\r\n\r\n    return serializedMap;\r\n  }\r\n\r\n  importState(state: Record<string, string[]>): void {\r\n    this.dataMap.clear();\r\n    \r\n    Object.entries(state).forEach(([key, value]) => {\r\n      this.dataMap.set(key, new Set(value));\r\n    });\r\n  }\r\n\r\n  clear(): void {\r\n    this.dataMap.clear();\r\n  }\r\n}","export class TrieNode {\r\n  children: Map<string, TrieNode>;\r\n  isEndOfWord: boolean;\r\n  documentRefs: Set<string>;\r\n  weight: number;\r\n\r\n  constructor() {\r\n      this.children = new Map();\r\n      this.isEndOfWord = false;\r\n      this.documentRefs = new Set();\r\n      this.weight = 0.0;\r\n  }\r\n}\r\n","import {  IndexableDocument, DocumentLink, SerializedState, SerializedTrieNode } from \"@/types\";\r\nimport { TrieNode } from \"./TrieNode\";\r\n\r\nexport class TrieSearch {\r\n    private root: TrieNode;\r\n    private documents: Map<string, IndexableDocument>;\r\n    private documentLinks: Map<string, DocumentLink[]>;\r\n\r\n    constructor() {\r\n        this.root = new TrieNode();\r\n        this.documents = new Map();\r\n        this.documentLinks = new Map();\r\n    }\r\n\r\n    public insert(text: string, documentId: string): void {\r\n        if (!text || !documentId) return;\r\n\r\n        const words = text.toLowerCase().split(/\\s+/).filter(Boolean);\r\n\r\n        for (const word of words) {\r\n            let current = this.root;\r\n\r\n            for (const char of word) {\r\n                if (!current.children.has(char)) {\r\n                    current.children.set(char, new TrieNode());\r\n                }\r\n                current = current.children.get(char)!;\r\n            }\r\n\r\n            current.isEndOfWord = true;\r\n            current.documentRefs.add(documentId);\r\n            current.weight += 1.0;\r\n        }\r\n    }\r\n\r\n    public search(query: string, maxResults: number = 10): Set<string> {\r\n        if (!query) return new Set();\r\n\r\n        const results = new Set<string>();\r\n        const words = query.toLowerCase().split(/\\s+/).filter(Boolean);\r\n\r\n        for (const word of words) {\r\n            let current = this.root;\r\n            let found = true;\r\n\r\n            for (const char of word) {\r\n                if (!current.children.has(char)) {\r\n                    found = false;\r\n                    break;\r\n                }\r\n                current = current.children.get(char)!;\r\n            }\r\n\r\n            if (found && current.isEndOfWord) {\r\n                this.collectDocumentRefs(current, results, maxResults);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public fuzzySearch(query: string, maxDistance: number = 2): Set<string> {\r\n        if (!query) return new Set();\r\n\r\n        const results = new Set<string>();\r\n        const words = query.toLowerCase().split(/\\s+/).filter(Boolean);\r\n\r\n        for (const word of words) {\r\n            this.fuzzySearchHelper(word, this.root, '', maxDistance, results);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    private collectDocumentRefs(node: TrieNode, results: Set<string>, maxResults: number): void {\r\n        if (node.isEndOfWord) {\r\n            for (const docId of node.documentRefs) {\r\n                if (results.size >= maxResults) return;\r\n                results.add(docId);\r\n            }\r\n        }\r\n\r\n        for (const child of node.children.values()) {\r\n            if (results.size >= maxResults) return;\r\n            this.collectDocumentRefs(child, results, maxResults);\r\n        }\r\n    }\r\n\r\n    private fuzzySearchHelper(\r\n        word: string,\r\n        node: TrieNode,\r\n        currentWord: string,\r\n        maxDistance: number,\r\n        results: Set<string>\r\n    ): void {\r\n        if (maxDistance < 0) return;\r\n\r\n        if (node.isEndOfWord) {\r\n            const distance = this.calculateLevenshteinDistance(word, currentWord);\r\n            if (distance <= maxDistance) {\r\n                node.documentRefs.forEach(id => results.add(id));\r\n            }\r\n        }\r\n\r\n        for (const [char, childNode] of node.children) {\r\n            const newDistance = word[currentWord.length] !== char ? maxDistance - 1 : maxDistance;\r\n            this.fuzzySearchHelper(word, childNode, currentWord + char, newDistance, results);\r\n\r\n            if (maxDistance > 0) {\r\n                this.fuzzySearchHelper(word, childNode, currentWord, maxDistance - 1, results);\r\n            }\r\n        }\r\n    }\r\n\r\n    private calculateLevenshteinDistance(s1: string, s2: string): number {\r\n        const dp: number[][] = Array(s1.length + 1).fill(0)\r\n            .map(() => Array(s2.length + 1).fill(0));\r\n\r\n        for (let i = 0; i <= s1.length; i++) dp[i][0] = i;\r\n        for (let j = 0; j <= s2.length; j++) dp[0][j] = j;\r\n\r\n        for (let i = 1; i <= s1.length; i++) {\r\n            for (let j = 1; j <= s2.length; j++) {\r\n                dp[i][j] = Math.min(\r\n                    dp[i - 1][j] + 1,\r\n                    dp[i][j - 1] + 1,\r\n                    dp[i - 1][j - 1] + (s1[i - 1] !== s2[j - 1] ? 1 : 0)\r\n                );\r\n            }\r\n        }\r\n\r\n        return dp[s1.length][s2.length];\r\n    }\r\n\r\n    public exportState(): SerializedState {\r\n        return {\r\n            trie: this.serializeNode(this.root),\r\n            documents: Array.from(this.documents.entries()),\r\n            documentLinks: Array.from(this.documentLinks.entries())\r\n        };\r\n    }\r\n\r\n    public importState(state: SerializedState): void {\r\n        this.root = this.deserializeNode(state.trie);\r\n        this.documents = new Map(state.documents);\r\n        this.documentLinks = new Map(state.documentLinks);\r\n    }\r\n\r\n    private serializeNode(node: TrieNode): SerializedTrieNode {\r\n        const children: { [key: string]: SerializedTrieNode } = {};\r\n\r\n        node.children.forEach((childNode, char) => {\r\n            children[char] = this.serializeNode(childNode);\r\n        });\r\n\r\n        return {\r\n            isEndOfWord: node.isEndOfWord,\r\n            documentRefs: Array.from(node.documentRefs),\r\n            weight: node.weight,\r\n            children\r\n        };\r\n    }\r\n\r\n    private deserializeNode(serialized: SerializedTrieNode): TrieNode {\r\n        const node = new TrieNode();\r\n        node.isEndOfWord = serialized.isEndOfWord;\r\n        node.documentRefs = new Set(serialized.documentRefs);\r\n        node.weight = serialized.weight ?? 0;\r\n\r\n        Object.entries(serialized.children).forEach(([char, childData]) => {\r\n            node.children.set(char, this.deserializeNode(childData));\r\n        });\r\n\r\n        return node;\r\n    }\r\n\r\n    public clear(): void {\r\n        this.root = new TrieNode();\r\n        this.documents.clear();\r\n        this.documentLinks.clear();\r\n    }\r\n\r\n    public getSize(): number {\r\n        return this.documents.size;\r\n    }\r\n}","import { TrieSearch } from \"@/algorithms/trie\";\r\nimport {  SearchableDocument, SearchResult, SerializedState } from \"@/types\";\r\nimport { DataMapper } from \"./DataMapper\";\r\n\r\nexport class IndexMapper {\r\n  private dataMapper: DataMapper;\r\n  private trieSearch: TrieSearch;\r\n\r\n  constructor() {\r\n    this.dataMapper = new DataMapper();\r\n    this.trieSearch = new TrieSearch();\r\n  }\r\n\r\n  indexDocument(document: SearchableDocument, id: string, fields: string[]): void {\r\n    fields.forEach(field => {\r\n        const value = document[field];\r\n        if (typeof value === 'string') {\r\n            const words = this.tokenizeText(value);\r\n            words.forEach(word => {\r\n                this.trieSearch.insert(word, id);\r\n                this.dataMapper.mapData(word.toLowerCase(), id);\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\n  search(query: string, options: { fuzzy?: boolean; maxResults?: number } = {}): SearchResult<string>[] {\r\n    const { fuzzy = false, maxResults = 10 } = options;\r\n    const searchTerms = this.tokenizeText(query);\r\n    \r\n    const documentScores = new Map<string, { score: number; matches: Set<string> }>();\r\n\r\n    searchTerms.forEach(term => {\r\n      const documentIds = fuzzy\r\n        ? this.trieSearch.fuzzySearch(term)\r\n        : this.trieSearch.search(term, maxResults);\r\n\r\n      documentIds.forEach(id => {\r\n        const current = documentScores.get(id) || { score: 0, matches: new Set<string>() };\r\n        current.score += this.calculateScore(id, term);\r\n        current.matches.add(term);\r\n        documentScores.set(id, current);\r\n      });\r\n    });\r\n\r\n    const results = Array.from(documentScores.entries())\r\n      .map(([id, { score, matches }]) => ({\r\n        item: id,\r\n        score: score / searchTerms.length,\r\n        matches: Array.from(matches)\r\n      }))\r\n      .sort((a, b) => b.score - a.score);\r\n\r\n    return results.slice(0, maxResults);\r\n  }\r\n\r\n  exportState(): unknown {\r\n    return {\r\n      trie: this.trieSearch.exportState(),\r\n      dataMap: this.dataMapper.exportState()\r\n    };\r\n  }\r\n\r\n  importState(state: { trie: SerializedState; dataMap: Record<string, string[]> }): void {\r\n    if (!state || !state.trie || !state.dataMap) {\r\n        throw new Error('Invalid index state');\r\n    }\r\n\r\n    this.trieSearch = new TrieSearch();\r\n    this.trieSearch.importState(state.trie );\r\n    this.dataMapper = new DataMapper();\r\n    this.dataMapper.importState(state.dataMap);\r\n}\r\n\r\n\r\n  private tokenizeText(text: string): string[] {\r\n    return text\r\n      .toLowerCase()\r\n      .replace(/[^\\w\\s]/g, ' ')\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 0);\r\n  }\r\n\r\n  private calculateScore(documentId: string, term: string): number {\r\n    const baseScore = this.dataMapper.getDocuments(term.toLowerCase()).has(documentId) ? 1.0 : 0.5;\r\n    return baseScore\r\n  \r\n  }\r\n  clear(): void {\r\n    this.trieSearch = new TrieSearch();\r\n    this.dataMapper = new DataMapper();\r\n  }\r\n}\r\n","import { IndexMapper } from \"@/mappers\";\r\nimport { \r\n    IndexConfig, \r\n    SearchOptions, \r\n    SearchResult, \r\n    IndexedDocument, \r\n    SearchableDocument, \r\n    SerializedState,\r\n    DocumentValue \r\n} from \"@/types\";\r\nimport { SerializedIndex } from \"@/types/core\";\r\nimport { createSearchableFields } from \"@/utils\";\r\n\r\nexport class IndexManager {\r\n    private indexMapper: IndexMapper;\r\n    private config: IndexConfig;\r\n    private documents: Map<string, IndexedDocument>;\r\n\r\n    constructor(config: IndexConfig) {\r\n        this.config = config;\r\n        this.indexMapper = new IndexMapper();\r\n        this.documents = new Map();\r\n    }\r\n\r\n    async addDocuments<T extends IndexedDocument>(documents: T[]): Promise<void> {\r\n        for (const [index, doc] of documents.entries()) {\r\n            const id = this.generateDocumentId(index);\r\n\r\n            // Convert document fields to Record<string, DocumentValue>\r\n            const contentRecord: Record<string, DocumentValue> = {};\r\n            for (const field of this.config.fields) {\r\n                if (field in doc) {\r\n                    contentRecord[field] = doc[field] as DocumentValue;\r\n                }\r\n            }\r\n\r\n            // Create searchable document with proper field extraction\r\n            const searchableDoc: SearchableDocument = {\r\n                id,\r\n                content: createSearchableFields({\r\n                    content: contentRecord,\r\n                    id\r\n                }, this.config.fields),\r\n                metadata: doc.metadata\r\n            };\r\n\r\n            // Store original document with ID\r\n            this.documents.set(id, { ...doc, id });\r\n\r\n            // Index the document\r\n            try {\r\n                await this.indexMapper.indexDocument(searchableDoc, id, this.config.fields);\r\n            } catch (error) {\r\n                console.warn(`Failed to index document ${id}:`, error);\r\n            }\r\n        }\r\n    }\r\n\r\n    async search<T extends IndexedDocument>(\r\n        query: string, \r\n        options: SearchOptions = {}\r\n    ): Promise<SearchResult<T>[]> {\r\n        if (!query.trim()) return [];\r\n\r\n        try {\r\n            const searchResults = await this.indexMapper.search(query, {\r\n                fuzzy: options.fuzzy ?? false,\r\n                maxResults: options.maxResults ?? 10\r\n            });\r\n\r\n            return searchResults\r\n                .filter(result => this.documents.has(result.item))\r\n                .map(result => ({\r\n                    item: this.documents.get(result.item) as T,\r\n                    score: result.score,\r\n                    matches: result.matches\r\n                }))\r\n                .filter(result => result.score >= (options.threshold ?? 0.5));\r\n\r\n        } catch (error) {\r\n            console.error('Search error:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    exportIndex(): SerializedIndex {\r\n        return {\r\n            documents: Array.from(this.documents.entries()).map(([key, value]) => ({\r\n                key,\r\n                value: this.serializeDocument(value)\r\n            })),\r\n            indexState: this.indexMapper.exportState(),\r\n            config: this.config\r\n        };\r\n    }\r\n\r\n    importIndex(data: unknown): void {\r\n        if (!this.isValidIndexData(data)) {\r\n            throw new Error('Invalid index data format');\r\n        }\r\n\r\n        try {\r\n            const typedData = data as SerializedIndex;\r\n            this.documents = new Map(\r\n                typedData.documents.map(item => [item.key, item.value])\r\n            );\r\n            this.config = typedData.config;\r\n            this.indexMapper = new IndexMapper();\r\n            \r\n            if (this.isValidIndexState(typedData.indexState)) {\r\n                this.indexMapper.importState({\r\n                    trie: typedData.indexState.trie,\r\n                    dataMap: typedData.indexState.dataMap\r\n                });\r\n            } else {\r\n                throw new Error('Invalid index state format');\r\n            }\r\n        } catch (error) {\r\n            const message = error instanceof Error ? error.message : 'Unknown error';\r\n            throw new Error(`Failed to import index: ${message}`);\r\n        }\r\n    }\r\n\r\n    clear(): void {\r\n        this.documents.clear();\r\n        this.indexMapper = new IndexMapper();\r\n    }\r\n\r\n    private generateDocumentId(index: number): string {\r\n        return `${this.config.name}-${index}-${Date.now()}`;\r\n    }\r\n\r\n    private isValidIndexData(data: unknown): data is SerializedIndex {\r\n        if (!data || typeof data !== 'object') return false;\r\n        \r\n        const indexData = data as Partial<SerializedIndex>;\r\n        return Boolean(\r\n            indexData.documents &&\r\n            Array.isArray(indexData.documents) &&\r\n            indexData.indexState !== undefined &&\r\n            indexData.config &&\r\n            typeof indexData.config === 'object'\r\n        );\r\n    }\r\n\r\n    private isValidIndexState(state: unknown): state is { trie: SerializedState; dataMap: Record<string, string[]> } {\r\n        return (\r\n            state !== null &&\r\n            typeof state === 'object' &&\r\n            'trie' in state &&\r\n            'dataMap' in state\r\n        );\r\n    }\r\n\r\n    private serializeDocument(doc: IndexedDocument): IndexedDocument {\r\n        return JSON.parse(JSON.stringify(doc));\r\n    }\r\n}","import { QueryToken } from \"@/types\";\r\n\r\n\r\nexport class QueryProcessor {\r\n  private readonly STOP_WORDS = new Set([\r\n    'a', 'an', 'and', 'are', 'as', 'at', 'be', 'by', 'for',\r\n    'from', 'has', 'he', 'in', 'is', 'it', 'its', 'of', 'on',\r\n    'that', 'the', 'to', 'was', 'were', 'will', 'with'\r\n  ]);\r\n\r\n  process(query: string): string {\r\n    const tokens = this.tokenize(query);\r\n    const processedTokens = this.processTokens(tokens);\r\n    return this.optimizeQuery(processedTokens);\r\n  }\r\n\r\n  private tokenize(query: string): QueryToken[] {\r\n    return query\r\n      .toLowerCase()\r\n      .split(/\\s+/)\r\n      .filter(term => term.length > 0)\r\n      .map(term => this.classifyToken(term));\r\n  }\r\n\r\n  private classifyToken(term: string): QueryToken {\r\n    if (term.startsWith('+') || term.startsWith('-')) {\r\n      return { type: 'operator', value: term };\r\n    }\r\n    if (term.includes(':')) {\r\n      return { type: 'modifier', value: term };\r\n    }\r\n    return { type: 'term', value: term };\r\n  }\r\n\r\n  private processTokens(tokens: QueryToken[]): QueryToken[] {\r\n    return tokens\r\n      .filter(token => \r\n        token.type !== 'term' || !this.STOP_WORDS.has(token.value)\r\n      )\r\n      .map(token => this.normalizeToken(token));\r\n  }\r\n\r\n  private normalizeToken(token: QueryToken): QueryToken {\r\n    if (token.type === 'term') {\r\n      // Basic stemming (could be enhanced with proper stemming algorithm)\r\n      let value = token.value;\r\n      if (value.endsWith('ing')) value = value.slice(0, -3);\r\n      if (value.endsWith('s')) value = value.slice(0, -1);\r\n      return { ...token, value };\r\n    }\r\n    return token;\r\n  }\r\n\r\n  private optimizeQuery(tokens: QueryToken[]): string {\r\n    return tokens\r\n      .map(token => token.value)\r\n      .join(' ');\r\n  }\r\n}","import { CacheManager, SearchStorage } from \"@/storage\";\r\nimport { SearchOptions, SearchResult, IndexedDocument, SearchEngineConfig } from \"@/types\";\r\nimport { validateSearchOptions } from \"@/utils\";\r\nimport { IndexManager } from \"../storage/IndexManager\";\r\nimport { QueryProcessor } from \"./QueryProcessor\";\r\n\r\n\r\n\r\nexport class SearchEngine {\r\n    private indexManager: IndexManager;\r\n    private queryProcessor: QueryProcessor;\r\n    private storage: SearchStorage;\r\n    private cache: CacheManager;\r\n    private config: SearchEngineConfig;\r\n    private isInitialized: boolean = false;\r\n\r\n    constructor(config: SearchEngineConfig) {\r\n        this.config = config;\r\n        this.indexManager = new IndexManager(config);\r\n        this.queryProcessor = new QueryProcessor();\r\n        this.storage = new SearchStorage(config.storage);\r\n        this.cache = new CacheManager();\r\n    }\r\n\r\n    async initialize(): Promise<void> {\r\n        if (this.isInitialized) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            // Initialize storage with fallback handling\r\n            try {\r\n                await this.storage.initialize();\r\n            } catch (storageError) {\r\n                console.warn('Storage initialization failed, falling back to memory storage:', storageError);\r\n                // Create new memory storage instance\r\n                this.storage = new SearchStorage({ type: 'memory' });\r\n                await this.storage.initialize();\r\n            }\r\n\r\n            // Load existing indexes\r\n            await this.loadIndexes();\r\n            this.isInitialized = true;\r\n        } catch (error) {\r\n            const errorMessage = error instanceof Error ? error.message : String(error);\r\n            throw new Error(`Failed to initialize search engine: ${errorMessage}`);\r\n        }\r\n    }\r\n\r\n    async addDocuments<T extends IndexedDocument>(documents: T[]): Promise<void> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        try {\r\n            // Add documents to index\r\n            await this.indexManager.addDocuments(documents);\r\n\r\n            // Store index in storage\r\n            try {\r\n                await this.storage.storeIndex(this.config.name, this.indexManager.exportIndex());\r\n            } catch (storageError) {\r\n                console.warn('Failed to persist index, continuing in memory:', storageError);\r\n            }\r\n\r\n            // Clear cache as index has changed\r\n            this.cache.clear();\r\n        } catch (error) {\r\n            const errorMessage = error instanceof Error ? error.message : String(error);\r\n            throw new Error(`Failed to add documents: ${errorMessage}`);\r\n        }\r\n    }\r\n\r\n    async search<T extends IndexedDocument>(\r\n        query: string, \r\n        options: SearchOptions = {}\r\n    ): Promise<SearchResult<T>[]> {\r\n        if (!this.isInitialized) {\r\n            await this.initialize();\r\n        }\r\n\r\n        validateSearchOptions(options);\r\n\r\n        // Try cache first\r\n        const cacheKey = this.generateCacheKey(query, options);\r\n        const cachedResults = this.cache.get(cacheKey);\r\n        if (cachedResults) {\r\n            return cachedResults as SearchResult<T>[];\r\n        }\r\n\r\n        try {\r\n            // Process query and perform search\r\n            const processedQuery = this.queryProcessor.process(query);\r\n            const results = await this.indexManager.search<T>(processedQuery, options);\r\n\r\n            // Cache results\r\n            this.cache.set(cacheKey, results);\r\n            return results;\r\n        } catch (error) {\r\n            const errorMessage = error instanceof Error ? error.message : String(error);\r\n            throw new Error(`Search failed: ${errorMessage}`);\r\n        }\r\n    }\r\n\r\n    private async loadIndexes(): Promise<void> {\r\n        try {\r\n            const storedIndex = await this.storage.getIndex(this.config.name);\r\n            if (storedIndex) {\r\n                this.indexManager.importIndex(storedIndex);\r\n            }\r\n        } catch (error) {\r\n            console.warn('Failed to load stored index, starting fresh:', error);\r\n        }\r\n    }\r\n\r\n    private generateCacheKey(query: string, options: SearchOptions): string {\r\n        return `${this.config.name}-${query}-${JSON.stringify(options)}`;\r\n    }\r\n\r\n    async clearIndex(): Promise<void> {\r\n        try {\r\n            await this.storage.clearIndices();\r\n        } catch (error) {\r\n            console.warn('Failed to clear storage, continuing:', error);\r\n        }\r\n        this.indexManager.clear();\r\n        this.cache.clear();\r\n    }\r\n\r\n    async close(): Promise<void> {\r\n        try {\r\n            await this.storage.close();\r\n            this.cache.clear();\r\n            this.isInitialized = false;\r\n        } catch (error) {\r\n            console.warn('Error during close:', error);\r\n        }\r\n    }\r\n}","export class SearchError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'SearchError';\r\n  }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'IndexError';\r\n  }\r\n}\r\n\r\nexport class ValidationError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n  }\r\n}\r\n\r\nexport class StorageError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'StorageError';\r\n  }\r\n}","import { SearchResult } from \"./search\";\r\n\r\nexport interface CacheOptions {\r\n    maxSize: number;\r\n    ttlMinutes: number;\r\n}\r\nexport interface CacheEntry {\r\n    data: SearchResult<unknown>[];\r\n    timestamp: number;\r\n    lastAccessed: number;\r\n    accessCount: number;\r\n}\r\n\r\n\r\n\r\nexport interface CacheOptions {\r\n    strategy: CacheStrategy;\r\n    maxSize: number;\r\n    ttlMinutes: number;\r\n}\r\n\r\nexport enum CacheStrategyType {\r\n    LRU = 'LRU',\r\n    MRU = 'MRU'\r\n  }\r\n\r\n  export type CacheStrategy = keyof typeof CacheStrategyType;\r\n  \r\n  export interface CacheStats {\r\n    hits: number;\r\n    misses: number;\r\n    evictions: number;\r\n}","// Import all types from a single barrel file\r\nimport type {\r\n    IndexConfig,\r\n    IndexOptions,\r\n    SearchContext,\r\n    SearchOptions,\r\n    SearchResult,\r\n    SearchStats,\r\n    SearchEventType,\r\n    SearchEvent,\r\n    DocumentLink,\r\n    DocumentRank,\r\n} from './types/index';\r\n\r\nexport { SearchContext,SearchStats, SearchEvent,SearchEventType,DocumentLink,DocumentRank}\r\n// Core imports\r\nimport { SearchEngine } from './core/SearchEngine';\r\nimport { IndexManager } from './storage/IndexManager';\r\nimport { QueryProcessor } from './core/QueryProcessor';\r\n\r\n// Algorithm imports\r\nimport { TrieNode } from './algorithms/trie/TrieNode';\r\nimport { TrieSearch } from './algorithms/trie/TrieSearch';\r\n\r\n// Mapper imports\r\nimport { DataMapper } from './mappers/DataMapper';\r\nimport { IndexMapper } from './mappers/IndexMapper';\r\n\r\n// Storage imports\r\nimport { CacheManager } from './storage/CacheManager';\r\nimport { IndexedDB } from './storage/IndexedDBService';\r\n\r\n// Utility imports\r\nimport {\r\n    PerformanceMonitor,\r\n    createSearchableFields,\r\n    optimizeIndex,\r\n    getNestedValue,\r\n    normalizeFieldValue,\r\n    validateSearchOptions,\r\n    validateIndexConfig,\r\n    validateDocument\r\n} from './utils/index';\r\n\r\n// Re-export all types\r\nexport * from './types/index';\r\n\r\n// Constants\r\nexport const DEFAULT_INDEX_OPTIONS: Required<IndexOptions> = {\r\n    caseSensitive: false,\r\n    stemming: true,\r\n    stopWords: ['the', 'a', 'an', 'and', 'or', 'but'],\r\n    minWordLength: 2,\r\n    maxWordLength: 50,\r\n    fuzzyThreshold: 0.8\r\n};\r\n\r\nexport const DEFAULT_SEARCH_OPTIONS: Required<SearchOptions> = {\r\n    fuzzy: false,\r\n    maxResults: 10,\r\n    threshold: 0.5,\r\n    fields: [],\r\n    sortBy: 'score',\r\n    sortOrder: 'desc',\r\n    page: 1,\r\n    pageSize: 10\r\n};\r\n\r\n// Error classes\r\nexport class SearchError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = 'SearchError';\r\n    }\r\n}\r\n\r\nexport class IndexError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        this.name = 'IndexError';\r\n    }\r\n}\r\n\r\n// Type guards\r\nexport function isSearchOptions(obj: unknown): obj is SearchOptions {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const options = obj as Partial<SearchOptions>;\r\n    \r\n    return (\r\n        (typeof options.fuzzy === 'undefined' || typeof options.fuzzy === 'boolean') &&\r\n        (typeof options.maxResults === 'undefined' || typeof options.maxResults === 'number')\r\n    );\r\n}\r\n\r\nexport function isIndexConfig(obj: unknown): obj is IndexConfig {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const config = obj as Partial<IndexConfig>;\r\n    \r\n    return Boolean(\r\n        typeof config.name === 'string' &&\r\n        typeof config.version === 'number' &&\r\n        Array.isArray(config.fields)\r\n    );\r\n}\r\n\r\nexport function isSearchResult<T>(obj: unknown): obj is SearchResult<T> {\r\n    if (!obj || typeof obj !== 'object') return false;\r\n    const result = obj as Partial<SearchResult<T>>;\r\n    \r\n    return Boolean(\r\n        'item' in result &&\r\n        typeof result.score === 'number' &&\r\n        Array.isArray(result.matches)\r\n    );\r\n}\r\n\r\n// Export individual components\r\nexport {\r\n    SearchEngine,\r\n    IndexManager,\r\n    QueryProcessor,\r\n    TrieNode,\r\n    TrieSearch,\r\n    DataMapper,\r\n    IndexMapper,\r\n    CacheManager,\r\n    IndexedDB,\r\n    PerformanceMonitor,\r\n    createSearchableFields,\r\n    optimizeIndex,\r\n    getNestedValue,\r\n    normalizeFieldValue,\r\n    validateSearchOptions,\r\n    validateIndexConfig,\r\n    validateDocument\r\n};\r\n\r\n// Create consolidated export object\r\nexport const NexusSearch = {\r\n    DEFAULT_INDEX_OPTIONS,\r\n    DEFAULT_SEARCH_OPTIONS,\r\n    SearchError,\r\n    IndexError,\r\n    SearchEngine,\r\n    IndexManager,\r\n    QueryProcessor,\r\n    TrieNode,\r\n    TrieSearch,\r\n    isSearchOptions,\r\n    isIndexConfig,\r\n    isSearchResult,\r\n} as const;\r\n\r\nexport default NexusSearch;","import { IndexOptions, SearchOptions, SearchDBSchema, IndexConfig, MetadataEntry } from \"@/types\";\r\nimport { IDBPDatabase, openDB } from \"idb\";\r\n\r\n\r\nexport const DEFAULT_INDEX_OPTIONS: Required<IndexOptions> = {\r\n  caseSensitive: false,\r\n  stemming: true,\r\n  stopWords: ['the', 'a', 'an', 'and', 'or', 'but'],\r\n  minWordLength: 2,\r\n  maxWordLength: 50,\r\n  fuzzyThreshold: 0.8\r\n};\r\n\r\nexport const DEFAULT_SEARCH_OPTIONS: Required<SearchOptions> = {\r\n  fuzzy: false,\r\n  maxResults: 10,\r\n  threshold: 0.5,\r\n  fields: [],\r\n  sortBy: 'score',\r\n  sortOrder: 'desc',\r\n  page: 1,\r\n  pageSize: 10\r\n  \r\n};\r\n\r\nexport class IndexedDB {\r\n  private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n  private readonly DB_NAME = 'nexus_search_db';\r\n  private readonly DB_VERSION = 1;\r\n  private initPromise: Promise<void> | null = null;\r\n\r\n  constructor() {\r\n    // Initialize immediately to catch early failures\r\n    this.initPromise = this.initialize();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.db) return;\r\n\r\n    try {\r\n      this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n        upgrade(db, oldVersion, newVersion, transaction) {\r\n          // Handle version upgrades\r\n          if (!db.objectStoreNames.contains('searchIndices')) {\r\n            const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n            indexStore.createIndex('timestamp', 'timestamp');\r\n          }\r\n\r\n          if (!db.objectStoreNames.contains('metadata')) {\r\n            const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\r\n            metaStore.createIndex('lastUpdated', 'lastUpdated');\r\n          }\r\n        },\r\n        blocked() {\r\n          console.warn('Database upgrade was blocked');\r\n        },\r\n        blocking() {\r\n          console.warn('Current database version is blocking a newer version');\r\n        },\r\n        terminated() {\r\n          console.error('Database connection was terminated');\r\n        }\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Storage initialization failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  private async ensureConnection(): Promise<void> {\r\n    if (this.initPromise) {\r\n      await this.initPromise;\r\n    }\r\n\r\n    if (!this.db) {\r\n      throw new Error('Database connection not available');\r\n    }\r\n  }\r\n\r\n  async storeIndex(key: string, data: any): Promise<void> {\r\n    await this.ensureConnection();\r\n\r\n    try {\r\n      const entry = {\r\n        id: key,\r\n        data,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      await this.db!.put('searchIndices', entry);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to store index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getIndex(key: string): Promise<any | null> {\r\n    await this.ensureConnection();\r\n\r\n    try {\r\n      const entry = await this.db!.get('searchIndices', key);\r\n      return entry?.data || null;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async updateMetadata(config: IndexConfig): Promise<void> {\r\n    await this.ensureConnection();\r\n\r\n    try {\r\n      const metadata: MetadataEntry = {\r\n        id: 'config', // Set id field\r\n        config,\r\n        lastUpdated: Date.now()\r\n      };\r\n\r\n      await this.db!.put('metadata', metadata); // No need to spread, directly use metadata\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to update metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getMetadata(): Promise<MetadataEntry | null> {\r\n    await this.ensureConnection();\r\n\r\n    try {\r\n      const result = await this.db!.get('metadata', 'config');\r\n      return result || null; // Return `null` if `result` is `undefined`\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async clearIndices(): Promise<void> {\r\n    await this.ensureConnection();\r\n\r\n    try {\r\n      await this.db!.clear('searchIndices');\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to clear indices: ${message}`);\r\n    }\r\n  }\r\n\r\n  async deleteIndex(key: string): Promise<void> {\r\n    await this.ensureConnection();\r\n\r\n    try {\r\n      await this.db!.delete('searchIndices', key);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to delete index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport class SearchStorage {\r\n  private db: IDBPDatabase<SearchDBSchema> | null = null;\r\n  private readonly DB_NAME = 'nexus_search_db';\r\n  private readonly DB_VERSION = 1;\r\n  private initPromise: Promise<void> | null = null;\r\n\r\n  constructor() {\r\n    // Initialize immediately to catch early failures\r\n    this.initPromise = this.initialize();\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.db) return;\r\n\r\n    try {\r\n      this.db = await openDB<SearchDBSchema>(this.DB_NAME, this.DB_VERSION, {\r\n        upgrade(db, oldVersion, newVersion, transaction) {\r\n          // Handle version upgrades\r\n          if (!db.objectStoreNames.contains('searchIndices')) {\r\n            const indexStore = db.createObjectStore('searchIndices', { keyPath: 'id' });\r\n            indexStore.createIndex('timestamp', 'timestamp');\r\n          }\r\n\r\n          if (!db.objectStoreNames.contains('metadata')) {\r\n            const metaStore = db.createObjectStore('metadata', { keyPath: 'id' });\r\n            metaStore.createIndex('lastUpdated', 'lastUpdated');\r\n          }\r\n        },\r\n        blocked() {\r\n          console.warn('Database upgrade was blocked');\r\n        },\r\n        blocking() {\r\n          console.warn('Current database version is blocking a newer version');\r\n        },\r\n        terminated() {\r\n          console.error('Database connection was terminated');\r\n        }\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Storage initialization failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  private async ensureConnection(): Promise<void> {\r\n    if (this.initPromise) {\r\n      await this.initPromise;\r\n    }\r\n    \r\n    if (!this.db) {\r\n      throw new Error('Database connection not available');\r\n    }\r\n  }\r\n\r\n  async storeIndex(key: string, data: any): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = {\r\n        id: key,\r\n        data,\r\n        timestamp: Date.now(),\r\n      };\r\n\r\n      await this.db!.put('searchIndices', entry);\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to store index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async getIndex(key: string): Promise<any | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const entry = await this.db!.get('searchIndices', key);\r\n      return entry?.data || null;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve index: ${message}`);\r\n    }\r\n  }\r\n\r\n  async updateMetadata(config: IndexConfig): Promise<void> {\r\n    await this.ensureConnection();\r\n  \r\n    try {\r\n      const metadata: MetadataEntry = {\r\n        id: 'config', // Set id field directly\r\n        config,\r\n        lastUpdated: Date.now()\r\n      };\r\n  \r\n      await this.db!.put('metadata', metadata); // Use metadata directly\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to update metadata: ${message}`);\r\n    }\r\n  }\r\n  \r\n\r\n  async getMetadata(): Promise<MetadataEntry | null> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      const result = await this.db!.get('metadata', 'config');\r\n      return result || null; // Return `null` if `result` is `undefined`\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to retrieve metadata: ${message}`);\r\n    }\r\n  }\r\n\r\n  async clearIndices(): Promise<void> {\r\n    await this.ensureConnection();\r\n    \r\n    try {\r\n      await this.db!.clear('searchIndices');\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error(`Failed to clear indices: ${message}`);\r\n    }\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n}\r\n","import { MetricsResult, PerformanceMetric } from \"@/types\";\r\n\r\nexport class PerformanceMonitor {\r\n    private metrics: Map<string, number[]>;\r\n\r\n    constructor() {\r\n        this.metrics = new Map();\r\n    }\r\n\r\n    async measure<T>(name: string, fn: () => Promise<T>): Promise<T> {\r\n        const start = performance.now();\r\n        try {\r\n            return await fn();\r\n        } finally {\r\n            const duration = performance.now() - start;\r\n            this.recordMetric(name, duration);\r\n        }\r\n    }\r\n\r\n    private recordMetric(name: string, duration: number): void {\r\n        if (!this.metrics.has(name)) {\r\n            this.metrics.set(name, []);\r\n        }\r\n        this.metrics.get(name)!.push(duration);\r\n    }\r\n\r\n    getMetrics(): MetricsResult {\r\n        const results: MetricsResult = {};\r\n\r\n        this.metrics.forEach((durations, name) => {\r\n            results[name] = {\r\n                avg: this.average(durations),\r\n                min: Math.min(...durations),\r\n                max: Math.max(...durations),\r\n                count: durations.length\r\n            } as PerformanceMetric;\r\n        });\r\n\r\n        return results;\r\n    }\r\n\r\n    private average(numbers: number[]): number {\r\n        return numbers.reduce((a, b) => a + b, 0) / numbers.length;\r\n    }\r\n\r\n    clear(): void {\r\n        this.metrics.clear();\r\n    }\r\n}"],"names":["CacheManager","constructor","maxSize","ttlMinutes","initialStrategy","this","cache","Map","ttl","strategy","accessOrder","stats","hits","misses","evictions","set","key","data","size","evict","entry","timestamp","Date","now","lastAccessed","accessCount","updateAccessOrder","get","isExpired","delete","removeFromAccessOrder","clear","getStats","hitRate","keyToEvict","findLRUKey","findMRUKey","length","push","unshift","index","indexOf","splice","setStrategy","newStrategy","entries","forEach","prune","prunedCount","analyze","totalAccesses","totalAccessCount","accessCounts","averageAccessCount","mostAccessedKeys","Array","from","sort","a","b","slice","map","count","SearchStorage","options","type","db","memoryStorage","storageType","determineStorageType","isIndexedDBAvailable","indexedDB","_a","initialize","openDB","upgrade","createObjectStore","keyPath","createIndex","error","console","warn","storeIndex","name","put","id","getIndex","clearIndices","close","createSearchableFields","document","fields","searchableFields","field","value","getNestedValue","content","undefined","normalizeFieldValue","toLowerCase","trim","isArray","v","join","Object","values","String","obj","path","keys","split","current","validateSearchOptions","maxResults","Error","threshold","DataMapper","dataMap","mapData","documentId","has","Set","add","getDocuments","getAllKeys","exportState","serializedMap","importState","state","TrieNode","children","isEndOfWord","documentRefs","weight","TrieSearch","root","documents","documentLinks","insert","text","words","filter","Boolean","word","char","search","query","results","found","collectDocumentRefs","fuzzySearch","maxDistance","fuzzySearchHelper","node","docId","child","currentWord","calculateLevenshteinDistance","childNode","newDistance","s1","s2","dp","fill","i","j","Math","min","trie","serializeNode","deserializeNode","serialized","childData","getSize","IndexMapper","dataMapper","trieSearch","indexDocument","tokenizeText","fuzzy","searchTerms","documentScores","term","score","matches","calculateScore","item","replace","IndexManager","config","indexMapper","addDocuments","doc","generateDocumentId","contentRecord","searchableDoc","metadata","_b","result","exportIndex","serializeDocument","indexState","importIndex","isValidIndexData","typedData","isValidIndexState","message","indexData","JSON","parse","stringify","QueryProcessor","STOP_WORDS","process","tokens","tokenize","processedTokens","processTokens","optimizeQuery","classifyToken","startsWith","includes","token","normalizeToken","endsWith","SearchEngine","isInitialized","indexManager","queryProcessor","storage","storageError","loadIndexes","errorMessage","cacheKey","generateCacheKey","cachedResults","processedQuery","storedIndex","clearIndex","ValidationError","super","StorageError","CacheStrategyType","DEFAULT_INDEX_OPTIONS","caseSensitive","stemming","stopWords","minWordLength","maxWordLength","fuzzyThreshold","DEFAULT_SEARCH_OPTIONS","sortBy","sortOrder","page","pageSize","SearchError","IndexError","isSearchOptions","isIndexConfig","version","isSearchResult","NexusSearch","DB_NAME","DB_VERSION","initPromise","oldVersion","newVersion","transaction","objectStoreNames","contains","blocked","blocking","terminated","ensureConnection","updateMetadata","lastUpdated","getMetadata","deleteIndex","metrics","measure","fn","start","performance","duration","recordMetric","getMetrics","durations","avg","average","max","numbers","reduce","sorted","localeCompare","originalSize","optimizedSize","compressionRatio","every"],"mappings":"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"}